// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RELATIONS_WASMTM_H_
#define FLATBUFFERS_GENERATED_RELATIONS_WASMTM_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

namespace wasmtm {

struct Edge;
struct EdgeBuilder;

struct Node;
struct NodeBuilder;

enum class ElemType : uint8_t {
  I8 = 0,
  U8 = 1,
  I16 = 2,
  U16 = 3,
  I32 = 4,
  U32 = 5,
  I64 = 6,
  U64 = 7,
  F32 = 8,
  F64 = 9,
  Str = 10,
  MIN = I8,
  MAX = Str
};

inline const ElemType (&EnumValuesElemType())[11] {
  static const ElemType values[] = {
    ElemType::I8,
    ElemType::U8,
    ElemType::I16,
    ElemType::U16,
    ElemType::I32,
    ElemType::U32,
    ElemType::I64,
    ElemType::U64,
    ElemType::F32,
    ElemType::F64,
    ElemType::Str
  };
  return values;
}

inline const char * const *EnumNamesElemType() {
  static const char * const names[12] = {
    "I8",
    "U8",
    "I16",
    "U16",
    "I32",
    "U32",
    "I64",
    "U64",
    "F32",
    "F64",
    "Str",
    nullptr
  };
  return names;
}

inline const char *EnumNameElemType(ElemType e) {
  if (flatbuffers::IsOutRange(e, ElemType::I8, ElemType::Str)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesElemType()[index];
}

struct Edge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EdgeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DST = 4,
    VT_ATTRS = 6
  };
  uint64_t dst() const {
    return GetField<uint64_t>(VT_DST, 0);
  }
  const flatbuffers::Vector<uint8_t> *attrs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ATTRS);
  }
  flexbuffers::Reference attrs_flexbuffer_root() const {
    return flexbuffers::GetRoot(attrs()->Data(), attrs()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_DST, 8) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           flexbuffers::VerifyNestedFlexBuffer(attrs(), verifier) &&
           verifier.EndTable();
  }
};

struct EdgeBuilder {
  typedef Edge Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dst(uint64_t dst) {
    fbb_.AddElement<uint64_t>(Edge::VT_DST, dst, 0);
  }
  void add_attrs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> attrs) {
    fbb_.AddOffset(Edge::VT_ATTRS, attrs);
  }
  explicit EdgeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Edge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Edge>(end);
    return o;
  }
};

inline flatbuffers::Offset<Edge> CreateEdge(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t dst = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> attrs = 0) {
  EdgeBuilder builder_(_fbb);
  builder_.add_dst(dst);
  builder_.add_attrs(attrs);
  return builder_.Finish();
}

struct Edge::Traits {
  using type = Edge;
  static auto constexpr Create = CreateEdge;
};

inline flatbuffers::Offset<Edge> CreateEdgeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t dst = 0,
    const std::vector<uint8_t> *attrs = nullptr) {
  auto attrs__ = attrs ? _fbb.CreateVector<uint8_t>(*attrs) : 0;
  return wasmtm::CreateEdge(
      _fbb,
      dst,
      attrs__);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NID = 4,
    VT_ATTRS = 6,
    VT_IDATA = 8,
    VT_ODATA = 10
  };
  uint64_t nid() const {
    return GetField<uint64_t>(VT_NID, 0);
  }
  const flatbuffers::Vector<uint8_t> *attrs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ATTRS);
  }
  flexbuffers::Reference attrs_flexbuffer_root() const {
    return flexbuffers::GetRoot(attrs()->Data(), attrs()->size());
  }
  const flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>> *idata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>> *>(VT_IDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>> *odata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>> *>(VT_ODATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NID, 8) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           flexbuffers::VerifyNestedFlexBuffer(attrs(), verifier) &&
           VerifyOffset(verifier, VT_IDATA) &&
           verifier.VerifyVector(idata()) &&
           verifier.VerifyVectorOfTables(idata()) &&
           VerifyOffset(verifier, VT_ODATA) &&
           verifier.VerifyVector(odata()) &&
           verifier.VerifyVectorOfTables(odata()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nid(uint64_t nid) {
    fbb_.AddElement<uint64_t>(Node::VT_NID, nid, 0);
  }
  void add_attrs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> attrs) {
    fbb_.AddOffset(Node::VT_ATTRS, attrs);
  }
  void add_idata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>>> idata) {
    fbb_.AddOffset(Node::VT_IDATA, idata);
  }
  void add_odata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>>> odata) {
    fbb_.AddOffset(Node::VT_ODATA, odata);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t nid = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> attrs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>>> idata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wasmtm::Edge>>> odata = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_nid(nid);
  builder_.add_odata(odata);
  builder_.add_idata(idata);
  builder_.add_attrs(attrs);
  return builder_.Finish();
}

struct Node::Traits {
  using type = Node;
  static auto constexpr Create = CreateNode;
};

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t nid = 0,
    const std::vector<uint8_t> *attrs = nullptr,
    const std::vector<flatbuffers::Offset<wasmtm::Edge>> *idata = nullptr,
    const std::vector<flatbuffers::Offset<wasmtm::Edge>> *odata = nullptr) {
  auto attrs__ = attrs ? _fbb.CreateVector<uint8_t>(*attrs) : 0;
  auto idata__ = idata ? _fbb.CreateVector<flatbuffers::Offset<wasmtm::Edge>>(*idata) : 0;
  auto odata__ = odata ? _fbb.CreateVector<flatbuffers::Offset<wasmtm::Edge>>(*odata) : 0;
  return wasmtm::CreateNode(
      _fbb,
      nid,
      attrs__,
      idata__,
      odata__);
}

inline const wasmtm::Node *GetNode(const void *buf) {
  return flatbuffers::GetRoot<wasmtm::Node>(buf);
}

inline const wasmtm::Node *GetSizePrefixedNode(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<wasmtm::Node>(buf);
}

inline bool VerifyNodeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<wasmtm::Node>(nullptr);
}

inline bool VerifySizePrefixedNodeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<wasmtm::Node>(nullptr);
}

inline void FinishNodeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<wasmtm::Node> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNodeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<wasmtm::Node> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace wasmtm

#endif  // FLATBUFFERS_GENERATED_RELATIONS_WASMTM_H_
